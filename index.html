<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Spelunking</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Courier New', Courier, monospace; background-color: #1a1a1a; }
        
        /* UI LAYOUT */
        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;
            display: flex; flex-direction: column; justify-content: space-between;
        }
        
        /* TOP HUD */
        #hud-top { padding: 20px; display: flex; justify-content: space-between; align-items: flex-start; }
        .totem-counter { 
            background: rgba(0,0,0,0.8); color: white; padding: 15px 25px; 
            border-radius: 4px; font-weight: bold; font-size: 1.4rem; 
            border: 1px solid #444;
            display: flex; align-items: center; gap: 10px;
        }
        .totem-slot { 
            width: 20px; height: 20px; border-radius: 2px; border: 2px solid #555; 
            background: #222; transition: 0.4s; 
        }
        .filled { border-color: white !important; box-shadow: 0 0 10px currentColor; transform: scale(1.2); }

        /* BOTTOM HUD */
        #hud-bottom { padding: 30px; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        #stamina-container { 
            width: 300px; height: 15px; background: #222; 
            border: 2px solid #555; border-radius: 4px; overflow: hidden; 
        }
        #stamina-bar { width: 100%; height: 100%; background: #FFD700; transition: width 0.1s linear; }
        #controls-hint { 
            color: rgba(255,255,255,0.6); font-size: 0.8rem; text-transform: uppercase; letter-spacing: 2px;
            opacity: 0; transition: opacity 1s; 
        }
        
        /* MESSAGES */
        #message-overlay {
            position: absolute; top: 40%; left: 50%; transform: translate(-50%, -50%);
            font-size: 2rem; color: #fff; font-weight: bold; 
            text-shadow: 0px 0px 10px rgba(0,0,0,1);
            opacity: 0; transition: opacity 0.5s; text-align: center; width: 100%;
        }

        /* START SCREEN */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center; color: white; pointer-events: auto; z-index: 10;
        }
        h1 { font-size: 5rem; margin: 0 0 40px 0; letter-spacing: 10px; color: #ccc; text-transform: uppercase; font-weight: 100; }
        
        button { 
            padding: 15px 60px; font-size: 1.5rem; background: transparent; color: white; 
            border: 2px solid white; cursor: pointer; letter-spacing: 5px;
            transition: 0.3s; font-family: 'Courier New', Courier, monospace;
        }
        button:hover { background: white; color: black; }

        /* FX */
        .shaking { animation: shake 0.5s infinite; }
        @keyframes shake { 0% { transform: translate(1px, 1px); } 50% { transform: translate(-1px, -1px); } 100% { transform: translate(1px, -1px); } }
        
        .cinematic-bar {
            position: absolute; left: 0; width: 100%; height: 0%; background: black; transition: height 0.5s; z-index: 5;
        }
        #bar-top { top: 0; }
        #bar-bottom { bottom: 0; }
        .cinematic-active #bar-top, .cinematic-active #bar-bottom { height: 15%; }

    </style>
</head>
<body class="cinematic-active">

    <div id="bar-top" class="cinematic-bar"></div>
    <div id="bar-bottom" class="cinematic-bar"></div>

    <div id="start-screen">
        <h1>SPELUNKING</h1>
        <button id="start-btn">BEGIN</button>
    </div>

    <div id="ui-layer">
        <div id="hud-top">
            <div class="totem-counter">
                <span>ARTIFACTS</span>
                <span id="slot-red" class="totem-slot" style="border-color:#ff4444"></span>
                <span id="slot-white" class="totem-slot" style="border-color:#eeeeee"></span>
                <span id="slot-green" class="totem-slot" style="border-color:#44ff44"></span>
                <span id="slot-black" class="totem-slot" style="border-color:#444444"></span>
                <span id="slot-blue" class="totem-slot" style="border-color:#4444ff"></span>
            </div>
            <div id="time-display" style="color: #ccc; font-weight: bold;">--:--</div>
        </div>
        <div id="message-overlay"></div>
        <div id="hud-bottom">
            <div id="stamina-container"><div id="stamina-bar"></div></div>
            <div id="controls-hint">WASD Move | SHIFT Sprint | SPACE Jump | F Flashlight</div>
        </div>
    </div>

    <!-- Three.js Import -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { PointerLockControls } from 'three/addons/controls/PointerLockControls.js';

        // --- CONFIGURATION ---
        const WORLD_RADIUS = 800; 
        const MOUNTAIN_HEIGHT = 450;
        const WATER_LEVEL = 10;
        const CHUNK_SIZE = 100;
        const DRAW_DISTANCE = 4;
        
        // --- GAME STATE ---
        let camera, scene, renderer, controls;
        let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
        let sprint = false, jumping = false, canJump = false;
        let velocity = new THREE.Vector3();
        let direction = new THREE.Vector3();
        let prevTime = performance.now();
        
        let stamina = 100;
        let collectedTotems = { red: false, white: false, green: false, black: false, blue: false };
        let playerHeight = 14;
        
        // Intro State
        let isIntro = false;
        let introStartTime = 0;
        const introOrigin = new THREE.Vector3(-300, 0, 300); // Starting spot

        // World Objects
        let sunLight, sunMesh, flashlight;
        let dayTime = 0.5; 
        const activeChunks = new Map();
        const totems = [];
        const birds = [];
        
        // Noise Helpers
        function pseudorandom(x, z) {
            let n = Math.sin(x * 12.9898 + z * 78.233) * 43758.5453;
            return n - Math.floor(n);
        }
        function noise(x, z) {
            const floorX = Math.floor(x), floorZ = Math.floor(z);
            const s = pseudorandom(floorX, floorZ), t = pseudorandom(floorX+1, floorZ);
            const u = pseudorandom(floorX, floorZ+1), v = pseudorandom(floorX+1, floorZ+1);
            const fX = x - floorX, fZ = z - floorZ;
            return (s + (t - s) * fX) + ((u + (v - u) * fX) - s - (t - s) * fX) * fZ; 
        }

        // --- CAVE PATH MATH ---
        // A winding path deep into the mountain
        function getCaveCenterZ(x) {
            // Path starts at x=100, wanders up to x=500
            return 100 + 60 * Math.sin((x - 100) * 0.03) + 20 * Math.cos(x * 0.1);
        }
        
        // --- HEIGHT FUNCTION ---
        function getHeight(x, z) {
            const dist = Math.sqrt(x*x + z*z);
            let h = 0;

            // Mountain Shape
            if (dist < WORLD_RADIUS) {
                h = MOUNTAIN_HEIGHT * Math.pow(1 - dist / WORLD_RADIUS, 2);
            }
            // Detail
            h += noise(x * 0.03, z * 0.03) * 15;
            h += noise(x * 0.1, z * 0.1) * 2;

            // Cave Carving
            // We dig a tunnel from X=100 to X=550
            if (x > 80 && x < 550) {
                const caveZ = getCaveCenterZ(x);
                const tunnelWidth = 20; // Radius of tunnel floor
                const distToPath = Math.abs(z - caveZ);

                if (distToPath < tunnelWidth) {
                    // Flatten floor inside the tunnel
                    // Add a slight upward slope to the cave floor
                    const caveFloorHeight = 30 + (x - 100) * 0.05; 
                    
                    // Smooth blending
                    const blend = Math.min(1, distToPath / tunnelWidth); // 0 at center, 1 at edge
                    h = (h * blend) + (caveFloorHeight * (1 - blend)); 
                    
                    // Ensure floor is flatish
                    if (h > caveFloorHeight && distToPath < tunnelWidth * 0.8) h = caveFloorHeight;
                }
            }

            // Water Bed
            if (h < WATER_LEVEL) h = -5;

            return h;
        }

        init();
        animate();

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);
            scene.fog = new THREE.Fog(0x87CEEB, 20, 500);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

            // Audio / Listener could go here

            // Lights
            const ambient = new THREE.AmbientLight(0xffffff, 0.1); // Very dark ambient for cave contrast
            scene.add(ambient);

            sunLight = new THREE.DirectionalLight(0xfffff0, 1.5);
            sunLight.castShadow = true;
            sunLight.shadow.mapSize.set(2048, 2048);
            sunLight.shadow.camera.top = 400;
            sunLight.shadow.camera.bottom = -400;
            sunLight.shadow.camera.left = -400;
            sunLight.shadow.camera.right = 400;
            sunLight.shadow.bias = -0.0005;
            scene.add(sunLight);
            
            // Visual Sun
            sunMesh = new THREE.Mesh(new THREE.SphereGeometry(30,16,16), new THREE.MeshBasicMaterial({color:0xFFD700}));
            scene.add(sunMesh);

            // Flashlight (Miner's lamp)
            flashlight = new THREE.SpotLight(0xffffff, 0, 100, Math.PI/4, 0.5, 1);
            flashlight.position.set(0,0,0);
            flashlight.target.position.set(0,0,-1);
            camera.add(flashlight);
            camera.add(flashlight.target);
            scene.add(camera);

            // Water
            const waterGeo = new THREE.PlaneGeometry(2000, 2000);
            waterGeo.rotateX(-Math.PI / 2);
            const waterMat = new THREE.MeshPhongMaterial({ color: 0x001e0f, transparent: true, opacity: 0.8, shininess: 100 });
            const water = new THREE.Mesh(waterGeo, waterMat);
            water.position.y = WATER_LEVEL;
            scene.add(water);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            controls = new PointerLockControls(camera, document.body);

            // UI Events
            document.getElementById('start-btn').addEventListener('click', startIntro);

            // Input
            const onKeyDown = (e) => {
                switch (e.code) {
                    case 'KeyW': moveForward = true; break;
                    case 'KeyA': moveLeft = true; break;
                    case 'KeyS': moveBackward = true; break;
                    case 'KeyD': moveRight = true; break;
                    case 'Space': 
                        if (canJump && stamina > 5) { velocity.y += 35; stamina -= 5; canJump = false; } 
                        jumping = true; 
                        break;
                    case 'ShiftLeft': sprint = true; break;
                    case 'KeyF': 
                        flashlight.intensity = flashlight.intensity > 0 ? 0 : 2; 
                        break;
                }
            };
            const onKeyUp = (e) => {
                switch (e.code) {
                    case 'KeyW': moveForward = false; break;
                    case 'KeyA': moveLeft = false; break;
                    case 'KeyS': moveBackward = false; break;
                    case 'KeyD': moveRight = false; break;
                    case 'Space': jumping = false; break;
                    case 'ShiftLeft': sprint = false; break;
                }
            };
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });

            // Initial Generation
            introOrigin.y = getHeight(introOrigin.x, introOrigin.z);
            camera.position.set(introOrigin.x, introOrigin.y + 1, introOrigin.z); // Lying down initially

            generateStaticProps();
        }

        function startIntro() {
            document.getElementById('start-screen').style.display = 'none';
            
            // Lock pointer immediately to capture input, but disable control logic updates
            controls.lock();
            controls.enabled = false; // Disable mouse look logic inside controls for now
            
            isIntro = true;
            introStartTime = performance.now();
        }

        // --- CHUNKS ---
        function updateChunks() {
            const px = camera.position.x;
            const pz = camera.position.z;
            const cx = Math.floor(px / CHUNK_SIZE);
            const cz = Math.floor(pz / CHUNK_SIZE);
            const needed = new Set();

            for (let x = -DRAW_DISTANCE; x <= DRAW_DISTANCE; x++) {
                for (let z = -DRAW_DISTANCE; z <= DRAW_DISTANCE; z++) {
                    needed.add(`${cx+x},${cz+z}`);
                }
            }
            
            activeChunks.forEach((mesh, key) => {
                if (!needed.has(key)) {
                    scene.remove(mesh);
                    mesh.geometry.dispose();
                    activeChunks.delete(key);
                }
            });

            needed.forEach(key => {
                if (!activeChunks.has(key)) {
                    const [mx, mz] = key.split(',').map(Number);
                    createChunk(mx, mz);
                }
            });
        }

        function createChunk(cx, cz) {
            const geo = new THREE.PlaneGeometry(CHUNK_SIZE, CHUNK_SIZE, 32, 32);
            geo.rotateX(-Math.PI / 2);
            const pos = geo.attributes.position;
            const colors = [];
            
            for(let i=0; i<pos.count; i++) {
                const wx = pos.getX(i) + cx * CHUNK_SIZE;
                const wz = pos.getZ(i) + cz * CHUNK_SIZE;
                const h = getHeight(wx, wz);
                pos.setY(i, h);

                // Colors
                if (h < WATER_LEVEL + 3) colors.push(0.76, 0.7, 0.5); // Sand
                else if (h < 80) colors.push(0.1, 0.5, 0.1); // Grass
                else if (h < 250) colors.push(0.4, 0.4, 0.4); // Rock
                else colors.push(0.9, 0.9, 0.95); // Snow

                // Darken cave path floor for visual cue
                if (wx > 90 && wx < 550) {
                     const pathZ = getCaveCenterZ(wx);
                     if (Math.abs(wz - pathZ) < 18) {
                         // Overwrite with dark grey/black
                         colors[colors.length-3] = 0.05;
                         colors[colors.length-2] = 0.05;
                         colors[colors.length-1] = 0.05;
                     }
                }
            }
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geo.computeVertexNormals();
            const mesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ vertexColors: true, flatShading: true, roughness: 1 }));
            mesh.position.set(cx*CHUNK_SIZE, 0, cz*CHUNK_SIZE);
            mesh.receiveShadow = true;
            scene.add(mesh);
            activeChunks.set(`${cx},${cz}`, mesh);
        }

        // --- PROPS ---
        function generateStaticProps() {
            // 1. Cave Roof & Walls
            // We iterate along the cave path and place rocks to cover it
            const rockGeo = new THREE.DodecahedronGeometry(15, 0);
            const rockMat = new THREE.MeshLambertMaterial({ color: 0x333333 });
            
            for(let x = 100; x < 550; x += 15) {
                const z = getCaveCenterZ(x);
                const y = getHeight(x, z);
                
                // Add Roof Rocks
                const roofH = y + 25; // Ceiling height
                // Place 3 rocks to form an arch
                const r1 = new THREE.Mesh(rockGeo, rockMat);
                r1.position.set(x, roofH, z);
                r1.scale.set(1.5, 0.5, 1.5);
                r1.castShadow = true;
                scene.add(r1);

                // Walls to block side light
                const r2 = new THREE.Mesh(rockGeo, rockMat);
                r2.position.set(x, roofH - 10, z + 20);
                r2.scale.set(1, 2, 1);
                r2.castShadow = true;
                scene.add(r2);

                const r3 = new THREE.Mesh(rockGeo, rockMat);
                r3.position.set(x, roofH - 10, z - 20);
                r3.scale.set(1, 2, 1);
                r3.castShadow = true;
                scene.add(r3);
                
                // Occasional Stalactite inside?
                if (Math.random() > 0.8) {
                    const stal = new THREE.Mesh(new THREE.ConeGeometry(1, 10), new THREE.MeshStandardMaterial({color:0x555555}));
                    stal.position.set(x + (Math.random()-0.5)*10, roofH - 5, z + (Math.random()-0.5)*10);
                    stal.rotation.x = Math.PI;
                    scene.add(stal);
                }
            }

            // 2. Trees (Outside)
            const treeGeo = new THREE.ConeGeometry(5, 20, 5);
            const treeMat = new THREE.MeshLambertMaterial({ color: 0x228b22 });
            const trunkGeo = new THREE.CylinderGeometry(1, 1, 5);
            for(let i=0; i<300; i++) {
                const r = 300 + Math.random() * 400;
                const a = Math.random() * Math.PI * 2;
                const x = Math.cos(a) * r;
                const z = Math.sin(a) * r;
                const y = getHeight(x, z);
                if (y > WATER_LEVEL && y < 200) {
                    const grp = new THREE.Group();
                    const l = new THREE.Mesh(treeGeo, treeMat); l.position.y = 10;
                    const t = new THREE.Mesh(trunkGeo, rockMat); t.position.y = 2.5;
                    grp.add(l, t);
                    grp.position.set(x, y, z);
                    grp.castShadow = true;
                    scene.add(grp);
                }
            }

            // 3. Totems
            // Red: Peak East
            addTotem('red', 0xff4444, new THREE.Vector3(200, 420, 0), "Dawn Witnessed.");
            // White: Peak West (Seagulls)
            addTotem('white', 0xeeeeee, new THREE.Vector3(-200, 380, 0), "Storm Survived.");
            // Green: Brush
            addTotem('green', 0x44ff44, new THREE.Vector3(-350, getHeight(-350, 200)+2, 200), "Nature Found.");
            // Blue: Water
            addTotem('blue', 0x4444ff, new THREE.Vector3(0, WATER_LEVEL+2, -600), "Depths Searched.");
            // Black: Deep Cave End
            addTotem('black', 0x111111, new THREE.Vector3(540, 55, getCaveCenterZ(540)), "Darkness Conquered.");

            // 4. Birds (White Totem Area)
            const birdGeo = new THREE.ConeGeometry(0.5, 2, 3); birdGeo.rotateX(Math.PI/2);
            for(let i=0; i<25; i++) {
                const b = new THREE.Mesh(birdGeo, new THREE.MeshBasicMaterial({color:0xffffff}));
                b.userData = { center: new THREE.Vector3(-200, 390, 0), t: Math.random()*100 };
                scene.add(b);
                birds.push(b);
            }
        }

        function addTotem(id, color, pos, msg) {
            const m = new THREE.Mesh(new THREE.OctahedronGeometry(2), new THREE.MeshStandardMaterial({color:color, emissive:color, emissiveIntensity:0.5}));
            m.position.copy(pos);
            const l = new THREE.PointLight(color, 5, 20);
            m.add(l);
            scene.add(m);
            totems.push({id, mesh: m, msg, collected: false, color});
        }

        // --- ANIMATION LOOP ---
        function animate() {
            requestAnimationFrame(animate);

            const time = performance.now();
            const delta = Math.min((time - prevTime) / 1000, 0.1);
            prevTime = time;

            // --- INTRO SEQUENCE ---
            if (isIntro) {
                const elapsed = (time - introStartTime) / 1000;
                
                // Phase 1: Stand up (0s - 2s)
                if (elapsed < 2.0) {
                    const t = elapsed / 2.0; // 0 to 1
                    // Easing cubic out
                    const ease = 1 - Math.pow(1 - t, 3);
                    camera.position.y = (introOrigin.y + 1) + (playerHeight - 1) * ease;
                    // Tilt look up slightly
                    camera.rotation.x = -Math.PI/4 * (1 - ease); 
                } 
                // Phase 2: Look Left/Right (2s - 4s)
                else if (elapsed < 4.5) {
                    camera.position.y = introOrigin.y + playerHeight;
                    const lookT = (elapsed - 2.0);
                    // Sine wave rotation for looking around
                    camera.rotation.y = Math.sin(lookT * 2) * 0.5; 
                    camera.rotation.x = 0;
                }
                // End Intro
                else {
                    isIntro = false;
                    controls.enabled = true; // Give control to player
                    flashlight.intensity = 2; // Auto turn on light
                    document.body.classList.remove('cinematic-active');
                    document.getElementById('controls-hint').style.opacity = 1;
                    showMessage("Find the 5 Artifacts");
                }
                
                // Still load chunks during intro so it looks nice
                updateChunks();
                return; // Skip game logic
            }

            if (controls.isLocked) {
                updateChunks();

                // Day Cycle
                const dayLen = 300; 
                const t = (time / 1000) / dayLen;
                const sunY = Math.sin(t * 6.28) * 500;
                const sunX = Math.cos(t * 6.28) * 500;
                sunLight.position.set(sunX, sunY, 100);
                sunMesh.position.copy(sunLight.position);
                sunLight.intensity = Math.max(0.05, Math.sin(t * 6.28));
                
                // Color Fog based on time (Sunrise/Sunset/Night)
                if (sunY < 0) scene.fog.color.setHex(0x050510); // Night
                else if (sunY < 100) scene.fog.color.setHex(0xffaa55); // Sunrise/Set
                else scene.fog.color.setHex(0x87CEEB); // Day

                // Physics
                velocity.x -= velocity.x * 5.0 * delta;
                velocity.z -= velocity.z * 5.0 * delta;
                velocity.y -= 30.0 * delta; // Gravity

                direction.z = Number(moveForward) - Number(moveBackward);
                direction.x = Number(moveRight) - Number(moveLeft);
                direction.normalize();

                const speed = (sprint && stamina > 0) ? 1000 : 500;
                if (sprint && direction.length() > 0) stamina -= 10 * delta;
                else if (stamina < 100) stamina += 5 * delta;
                
                document.getElementById('stamina-bar').style.width = stamina + '%';

                if (moveForward || moveBackward) velocity.z -= direction.z * speed * delta;
                if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

                controls.moveRight(-velocity.x * delta);
                controls.moveForward(-velocity.z * delta);

                const pos = camera.position;
                const ground = getHeight(pos.x, pos.z);
                
                if (pos.y < ground + playerHeight) {
                    velocity.y = 0;
                    pos.y = ground + playerHeight;
                    canJump = true;
                }

                // Birds Logic
                birds.forEach(b => {
                    b.userData.t += delta;
                    b.position.copy(b.userData.center);
                    b.position.x += Math.sin(b.userData.t) * 30;
                    b.position.z += Math.cos(b.userData.t * 0.7) * 30;
                    b.position.y += Math.sin(b.userData.t * 2.5) * 10;
                    b.lookAt(b.userData.center);
                    
                    if (pos.distanceTo(b.userData.center) < 80) {
                         if (Math.random() > 0.9) document.body.classList.toggle('shaking');
                         stamina -= delta * 2;
                    }
                });

                // Totem Logic
                totems.forEach(totem => {
                    if(totem.collected) {
                        totem.mesh.rotation.y += 0.1; 
                        totem.mesh.position.y += Math.sin(time*0.01)*0.1;
                        return;
                    }
                    totem.mesh.rotation.y += 0.02;
                    if (pos.distanceTo(totem.mesh.position) < 10) {
                        if (totem.id === 'red' && sunLight.position.y > 50) {
                             showMessage("Wait for Sunrise..."); return;
                        }
                        totem.collected = true;
                        totem.mesh.visible = false;
                        collectedTotems[totem.id] = true;
                        document.getElementById(`slot-${totem.id}`).classList.add('filled');
                        document.getElementById(`slot-${totem.id}`).style.backgroundColor = '#' + totem.color.toString(16);
                        showMessage(totem.msg);
                    }
                });
            }

            renderer.render(scene, camera);
        }

        function showMessage(txt) {
            const el = document.getElementById('message-overlay');
            el.innerText = txt;
            el.style.opacity = 1;
            setTimeout(() => el.style.opacity = 0, 3000);
        }

    </script>
</body>
</html>
